###Extract LD clumped HaemGen platelet count and mean platelet volume GWAS from MR-Base###

###Standardise GWAS for input into genetic risk score script###

###Generate genetic risk score####

##Use script 'PLINK_platelet_PRS_noUKB_bgen.sh derived from Rebecca Richmond 

#!/bin/bash

#PBS -N PRS_MPV
#PBS -o PRS_MPV
#PBS -e PRS_MPV_error
#PBS -l walltime=24:00:00
#PBS -l nodes=1:ppn=2
#PBS -S /bin/bash

cd /projects/MRC-IEU/research/projects/ieu1/wp1/028/working/data/results/UKBB/Phenotypes/Platelet_phenotypes_and_medication/Input/PRS

module load apps/plink-2.00

for i in {10..22}
do
rm /projects/MRC-IEU/research/projects/ieu1/wp1/028/working/data/results/UKBB/Phenotypes/Platelet_phenotypes_and_medication/Input/PRS/HaemGen_MPV_GRS_${i}-temporary.*
plink \
--data data.chr \
--bgen /projects/MRC-IEU/research/data/ukbiobank/genetic/variants/arrays/imputed/released/2018-09-18/data/dosage_bgen/data.chr${i}.bgen \
--sample /projects/MRC-IEU/research/data/ukbiobank/genetic/variants/arrays/imputed/released/2018-09-18/data/dosage_bgen/data.chr1-22_plink.sample \
--score /projects/MRC-IEU/research/projects/ieu1/wp1/028/working/data/results/UKBB/Phenotypes/Platelet_phenotypes_and_medication/Input/PRS/ieu-a-1006_HaemGen_MPV_SD_input \
--out /projects/MRC-IEU/research/projects/ieu1/wp1/028/working/data/results/UKBB/Phenotypes/Platelet_phenotypes_and_medication/Input/PRS/HaemGen_MPV_PRS_noukb${i} \

done

#Rename Allele score column to reflect chromosome number and join each chromosome file 

#Join using 'paste' files and keep columns: FID, IID and SCORE1_AVG_CHR(1-22) 

###Perform one-sample MR###

##UK Biobank Overall - Acute MI on Platelet count 

#Install relevant R packages 
install.packages("ivreg") 

#Read in relevant packages
library(ivreg) 

#Read in files 
data <- read.table("/projects/MRC-IEU/research/projects/ieu1/wp1/028/working/data/results/UKBB/Phenotypes/Platelet_phenotypes_and_medication/Model_selfreported_ICD9_ICD10/IEU_output_extracted_plateletphenotypes_acuteMI_mortalityafterMI_DVT_PE_covariates_PC40_withIDS_FINAL", header = T) 

PLT_GRS <- read.table("/projects/MRC-IEU/research/projects/ieu1/wp1/028/working/data/results/UKBB/Phenotypes/Platelet_phenotypes_and_medication/Input/PRS/HaemGen_PLT_GRS_chr1_22", header = T) 

#2SLS analyses - Binary outcome
#In a two-stage analysis using a binary outcome (case-control setting) requires use of logistic regression with the inference on the controls only (where Y = 0). This can be performed by sequential regression using the 'predict' function 

g = PLT_GRS$PLT_GRS 

g0=g[data$Acute_MI==0]

ivmodel.UKBall.PLT <- glm(data$Acute_MI ~ predict(lm(data$PLT_initial_SD[data$Acute_MI==0]~g0), newdata=list(g0=g)), family = binomial)

summary(ivmodel.UKBall.PLT)
summary(ivmodel.UKBall.PLT)$coef[2] # 2SLS estimate 
summary(ivmodel.UKBall.PLT)$coef[2,2] # Standard error of 2SLS estimate 




#TEST#
#Read in relevant packages
library(ivreg)

#Read in data
data <- read.table("/projects/MRC-IEU/research/projects/ieu1/wp1/028/working/data/results/UKBB/Phenotypes/Platelet_phenotypes_and_medication/Model_selfreported_ICD9_ICD10/IEU_output_extracted_plateletphenotypes_acuteMI_mortalityafterMI_DVT_PE_covariates_PC40_withIDS_FINAL", header = T) 
PLT_GRS <- read.table("/projects/MRC-IEU/research/projects/ieu1/wp1/028/working/data/results/UKBB/Phenotypes/Platelet_phenotypes_and_medication/Input/PRS/HaemGen_PLT_GRS_chr1_22", header = T) 

#Extract names of variables
variables<-names(data)

# Number of X1s plus adjusted covs not PCs
# X1 + X2 + X3 + X4 (4)
# A1 + A2 + A3 (3)  

num.exposures<- 6 + 8

#g is sum of allele scores 
g = PLT_GRS$PLT_GRS 

#Create empty data frame for results
res<-matrix( rep( 0, len= num.exposures^2), nrow = num.exposures)
res.se<-matrix( rep( 0, len= num.exposures^2), nrow = num.exposures)
res.pvalue<-matrix( rep( 0, len= num.exposures^2), nrow = num.exposures)

#Regress each variable on all other variables, saving results
for(i in 1:ncol(res)){
  
  t.outcome<-variables[i]
  
  t.exposure.list<-variables[-i]
  
  g0=g[t.outcome==0]
  
  t.res<-rep(0,(num.exposures-1))
  
  t.pvalue<-rep(0,(num.exposures-1))
  
  t.se<-rep(0,(num.exposures-1))
     
  for(j in 1:(num.exposures-1)){
    
    t.exposures<-paste(t.exposure.list[j])
    
    t.exposures<-paste(c(t.exposures,variables[(num.exposures-2):length(variables)]))
    
    t.exposures<-unique(t.exposures)
    
    t.exposures<-t.exposures[t.exposures!=t.outcome]
    
    t.exposures<-paste(t.exposures,collapse="+")
    
    t.formula<-as.formula(paste(t.outcome ~ predict(lm(t.exposures[t.outcome==0]~g0, newdata=list(g0=g))
    
    if(is.integer(data[,i])){
      
      mod.t<-summary(glm(t.formula,data=data,family="binomial"))
      
      t.res[j]<-mod.t$coefficients[2,1]
      t.se[j]<-mod.t$coefficients[2,2]
      t.pvalue[j]<-mod.t$coefficients[2,4]
      
    }else{
      
      mod.t<-summary(lm(t.formula,data=data))
      
      t.res[j]<-mod.t$coefficients[2,1]
      t.se[j]<-mod.t$coefficients[2,2]
      t.pvalue[j]<-mod.t$coefficients[2,4]
      
    }
    
  }
  
  #Making 1 on diagonal
  
  if(i == 1){
    
    t.res<-c(1,t.res)
    t.se<-c(1,t.se)
    t.pvalue<-c(1,t.pvalue)
    
  }
  
  if(i == num.exposures){
    
    t.res<-c(t.res,1)
    t.se<-c(t.se,1)
    t.pvalue<-c(t.pvalue,1)
    
  }
  
  if(i != 1 & i != num.exposures){
    
    t.res<-c(t.res[1:(i-1)],1,t.res[i:(num.exposures-1)])
    t.se<-c(t.se[1:(i-1)],1,t.se[i:(num.exposures-1)])
    t.pvalue<-c(t.pvalue[1:(i-1)],1,t.pvalue[i:(num.exposures-1)])
    
  }
  
  #Populating zero matrices
  
  res[,i]<-t.res
  res.se[,i]<-t.se
  res.pvalue[,i]<-t.pvalue
  
}

#Making it look pretty

results<-data.frame(res)

names(results)<-variables[1:num.exposures]

row.names(results)<-variables[1:num.exposures]

se.data<-data.frame(res.se)

names(se.data)<-variables[1:num.exposures]

row.names(se.data)<-variables[1:num.exposures]

pval.data<-data.frame(res.pvalue)

names(pval.data)<-variables[1:num.exposures]

row.names(pval.data)<-variables[1:num.exposures]
